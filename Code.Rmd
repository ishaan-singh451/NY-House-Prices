---
title: "NY Housing Pricing Project"
author: 'Ishaan SIngh, '
date: "30/10/2020"
output: pdf_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r, echo = FALSE,include = FALSE}

# Importing the relevant libraries

library(tidyverse)
library(corrplot)
library(qtlcharts)

```



```{r data import, include = FALSE}

# Importing the data and performing data munging

data = read.delim("Housing Prices NY.txt")

glimpse(data) 

colSums(is.na(data)) # checking for NA values in the data

# Converting categorical attributes into the factor type

data$Fuel.Type = as.factor(data$Fuel.Type)
data$Heat.Type = as.factor(data$Heat.Type)
data$Sewer.Type = as.factor(data$Sewer.Type)


# Creating the test-train split
train.data = data %>%
    filter(data$Test == 0)
test.data = data %>%
    filter(data$Test == 1)

nrow(train.data)/(nrow(train.data) + nrow(test.data)) # 75% of the data is used for training

```




```{r model select}

# MODEL SELECTION

model = lm(Price ~ . , data = data)
model = update(model, .~. - Test)

new_model = update(model, .~. - Sewer.Type - Fireplaces - Fuel.Type - Pct.College - Age)
drop1(new_model, test = "F")

summary(model)$r.squared
summary(new_model)$r.squared

summary(model)$adj.r.squared
summary(new_model)$adj.r.squared


```



```{r assumption testing}

# NORMALITY OF ERROR TERMS

residuals  = resid(new_model)

qqnorm(residuals)
qqline(residuals)

hist(residuals, main = "Distribution of Residuals", xlab = "Residuals", freq = TRUE)


# LINEARITY AND CONDITIONAL MEAN INDEPENDENCE ASSUMPTIONS TESTING

plot(residuals)


# MULTICOLLINEARITY ASSUMPTION TESTING

numeric.data = data[c("Lot.Size", "Land.Value", "Bedrooms", "Rooms", "Bathrooms", "Living.Area")]

iplotCorr(numeric.data)


# HOMOSKEDASTICITY ASSUMPTION TESTING

par(mfrow = c(3,2))

# Bedrooms
Bedrooms = data$Bedrooms

plot(residuals ~ Bedrooms, main = "Bedrooms") # the same must be done for other regressors
abline(lm(residuals ~ Bedrooms), col="red")

# Land Value
Land_Value = data$Land.Value

plot(residuals ~ Land_Value, main = "Land Value")
abline(lm(residuals ~ Land_Value), col="red")

# Living Area
Living_Area = data$Living.Area

plot(residuals ~ Living_Area, main = "Living Area")
abline(lm(residuals ~ Living_Area), col="red")

# Bathrooms
Bathrooms = data$Bathrooms

plot(residuals ~ Bathrooms, main = "Bathrooms")
abline(lm(residuals ~ Bathrooms), col="red")

# Lot Size
Lot_Size = data$Lot.Size

plot(residuals ~ Lot_Size, main = "Lot Size")
abline(lm(residuals ~ Lot_Size), col="red")

# Age
Age = data$Age

plot(residuals ~ Age, main = "Age")
abline(lm(residuals ~ Age), col="red")


```




```{r performance}

# Testing Performance via Cross Validation

set.seed(2)
set = data
folding = c(rep(1:17, each = 102))
set$folding = sample(folding, replace = FALSE)
# head(set)


k = 17
mse = full_mse = vector(mode = "numeric", length = k)
mae = full_mae = vector(mode = "numeric", length = k)

for(i in 1:k) {
    test_set = set[folding == i,]
    training_set = set[folding != i,]
    lm = lm(Price ~ . , data = training_set)
    lm = update(model, .~. - Test - Sewer.Type - Fireplaces - Fuel.Type - Pct.College - Age - folding)
    
    pred = predict(lm, test_set)
    mse[i] = mean((test_set$Price - pred)^2)
    mae[i] = mean(abs(test_set$Price - pred))
    
    full.lm = lm(Price ~ . , data = training_set)
    full.lm = update(model, .~. - Test - folding - Fuel.Type)
    
    full.pred = predict(full.lm, test_set)
    full_mse[i] = mean((test_set$Price - full.pred)^2)
    full_mae[i] = mean(abs(test_set$Price - full.pred))
}

tab = data.frame(sqrt(mse), sqrt(full_mse), mae, full_mae)
names(tab) = c("Restricted RMSE", "Unrestricted RMSE", "Restricted MAE", "Unrestricted MAE")

boxplot(tab[,c(1,2)], main = "Root Mean Squared Errors")
boxplot(tab[,c(3,4)], main = "Mean Absolute Errors")


# Creating Prediction and Confidence Intervals



```